import logging  import numpy as npimport pandas as pdimport datetime as dateimport matplotlib.pyplot as plt from concepts import Debt# Set up logging. logger = logging.getLogger('')logger.setLevel(logging.DEBUG)ch = logging.StreamHandler()ch.setLevel(logging.DEBUG)# formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')formatter = logging.Formatter('%(message)s')ch.setFormatter(formatter)logger.handlers.clear()logger.addHandler(ch)# Okay. Step 1. Model the growth of a test debt that I have, using easily verifiable numbers, to ensure that things are working correctly. def describe_debts(debts):         active_debts = {x: y for x,y in debts.items() if y.balance > 0}    cleared_debts = {x: y for x,y in debts.items() if y.balance == 0}        if len(active_debts) > 0:        logger.debug('\nActive Debt Status:')        for _, debt in active_debts.items():             logger.debug('%15s: $%0.2f of $%0.2f - Costing $%0.2f/year ' % (debt.name, debt.balance, debt.limit, debt.annual_interest))                logger.debug('\nCleared Debt Status:')    for _, debt in cleared_debts.items():         logger.debug('%15s: $%0.2f available' % (debt.name, debt.available_credit))            return None def get_current_state(debts):         cs = {        'total_debt': 0,         'total_limit': 0,         'total_revolving_limit': 0,        'total_available_credit': 0,         'total_annual_interest_due': 0,         'total_credit_utilization': 0}        for _, debt in debts.items():         cs['total_debt'] += debt.balance          cs['total_limit'] += debt.limit        cs['total_revolving_limit'] += debt.limit if debt.revolving==True else debt.balance        cs['total_available_credit'] += debt.available_credit         cs['total_annual_interest_due'] += debt.annual_interest     cs['total_credit_utilization'] = cs['total_debt']/cs['total_revolving_limit']    return cs def load_debts(path='/Users/soren/Desktop/financial_model/data/debts.csv'):    '''        Path: (str): The path to the CSV file holding the debt info.         It should contain the following columns:                     Returns: A dictionary of debt objects, where the key is the debt name         and the value is the debt object.     '''        logger.debug('Ingesting debts from path: %s' % (path))    debts = {y['name']: Debt(**y) for x, y in pd.read_csv(path).to_dict(orient='index').items()}    logger.debug('Successfully imported debts.\n\n')    return debts    def borrow_from_lowest_interest_product(amount, debts):     """        amount: The amount to try to borrow         debts:  The credit products available                 Returns: The amount that was successfully borrowed from the available credit     """        # Steps     # 1. Identify debts in order of lowest interest, that have credit available     # 2. Withdraw from the lowest interest product that offers revolving credit until the amount required has been withdrawn.         lowest_interest_revolving_debts = sorted([debt for debt in debts.values() if debt.revolving==True],                                              key=lambda x: x.apr)        amount_withdrawn = 0        # I need logic to split the amount I wish to withdraw among the available sources of credit     for debt in lowest_interest_revolving_debts:         if debt.available_credit - amount >= 0:             debt.withdrawal(amount)            amount_withdrawn = amount             break         else:             amount_withdrawn += debt.available_credit             debt.withdrawal(debt.available_credit)        return amount_withdrawn def apply_remaining_cash_highest_interest_debts(cash_available, debts):    """        cash_available: A float representing how much money is left after all minimum payments have been made         debts:          A dictionary of debt objects.    """        # Logic. Apply the remaining payment to the highest interest debt.     # In the edge case where the balance on the highest interest debt is less than the remaining cash, pay off the highest interest_debt and apply remaining cash to the next remaining debt.     logger.debug('Directing remaining cash towards highest interest debts')    highest_interest_debts = sorted([debt for debt in debts.values() if debt.balance > 0], key=lambda x: x.apr, reverse=True)    debt_idx = 0            # Okay. What do I log here?     counter = 0    while cash_available > 0 and debt_idx < len(highest_interest_debts):                     # If all the cash will go towards one balance         if highest_interest_debts[debt_idx].balance >= cash_available:             highest_interest_debts[debt_idx].payment(cash_available)            logger.debug('\tUsed all remaining cash to make payment of $%0.2f towards %s' % (cash_available, highest_interest_debts[debt_idx].name))            cash_available -= cash_available                        else:             # If we can completely pay off the highest interest debt and have leftover cash                                     payment_to_current_debt = highest_interest_debts[debt_idx].balance             cash_available -= payment_to_current_debt            highest_interest_debts[debt_idx].payment(payment_to_current_debt)            logger.debug('\tUsed $%0.2f to pay %s, with $%0.2f remaining' % (payment_to_current_debt, highest_interest_debts[debt_idx].name, cash_available))            debt_idx += 1             # Okay. my logic to calculate the payment to the current debt is incorrect...             # I need more robust logic to account for when cash can be less or more than         counter += 1        return cash_available     if __name__ == '__main__':         results = []    num_months = 60    logger.debug('Running simulation for %d months.' % (num_months))    debts = load_debts()        for m in range(0, num_months):         logger.debug('\n***************************\n* NOW SIMULATING MONTH: %d *\n***************************\n' % (m))        total_cash_available = 1000                ms = {'month': m,             'total_debt': 0,             'total_limit': 0,             'total_available_credit': 0,             'total_revolving_limit': 0,             'total_annual_interest_due': 0,             'total_min_payments': 0,             'total_shortfall': 0}        logger.debug('Compounding all outstanding debts\n---------------------')        for debt_name, debt in debts.items():                         if debt.balance > 0:                 debt.compound()                debt.calculate_minimum_payment()            ms['total_limit'] += debt.limit             ms['total_debt'] += debt.balance            ms['total_min_payments'] += debt.minimum_payment            ms['total_revolving_limit'] += debt.limit if debt.revolving==True else debt.balance            ms['total_available_credit'] += debt.available_credit            ms['total_annual_interest_due'] += debt.annual_interest            if debt.balance > 0:                 logger.debug('Compounded %s\n\t%20s: $%6.2f\n\t%20s: $%6.2f\n\t%20s: $%6.2f' % (debt.name, 'New Balance', debt.balance, 'Annual Interest', debt.annual_interest, ' Min Payment', debt.minimum_payment))                # Calculate credit utilization         ms['total_credit_utilization'] = ms['total_debt']/ms['total_revolving_limit']                # STEP 1. IDENTIFY HOW MUCH CASH IS REQUIRED TO MEET MIN PAYMENTS, AND BORROW MORE IF REQUIRED         logger.debug('\n\nCheck for sufficient cash to make minimum payments\n-------------------------------------------------')        logger.debug('Total cash available/required for minimum payments: $%0.2f / $%0.2f' % (total_cash_available, ms['total_min_payments']))        monthly_cash_shortfall = round(ms['total_min_payments'] - total_cash_available, 2)                if monthly_cash_shortfall > 0:                         logger.warning('WARNING! Need $%0.2f more to make minimum payments.' % (monthly_cash_shortfall))                        if monthly_cash_shortfall < ms['total_available_credit']:                                logger.debug('Attempting to withdraw $%0.2f from revolving credit to meet min payments' % (monthly_cash_shortfall))                amount_withdrawn = borrow_from_lowest_interest_product(monthly_cash_shortfall, debts)                total_cash_available += amount_withdrawn                ms['total_shortfall'] += amount_withdrawn                 logger.debug ('Successfully withdrew $%0.2f to cover monthly shortfall\n' % (amount_withdrawn))            else:                 raise Exception('NOT ENOUGH CREDIT AVAILABLE FOR MINIMUM PAYMENT - GAME OVER')              else:            logger.debug('Sufficient cash available!')                                # STEP 2. MAKE THE MINIMUM PAYMENTS         logger.debug('\n\nMake Minimum Payments\n---------------------')        logger.debug('Total min payments required: $%0.2f' % ms['total_min_payments'])                for debt_name, debt in debts.items():             if debt.balance > 0:                 debt_min_payment = debt.minimum_payment                 debt.payment(debt.minimum_payment)                total_cash_available -= debt_min_payment                logger.debug('\tMade min payment of $%0.2f to %s' % (debt_min_payment, debt_name))        logger.debug('\nCash remaining after all minimum payments: $%0.2f' % (total_cash_available))                # STEP 3. APPLY ANY EXCESS CASH TOWARDS HIGHEST INTERST DEBT               if ms['total_shortfall'] == 0 and total_cash_available > 0:            logger.debug('\n\nMake Extra Payments\n---------------------')            logger.debug('Cash available for extra payments $%0.2f' % (total_cash_available))            total_cash_available = apply_remaining_cash_highest_interest_debts(total_cash_available, debts)                # STEP 4. Summarize current status of debts after payments and withdrawals         cs = get_current_state(debts)        logger.debug('\n\nEND OF MONTH %d REPORT\n--------------------' % (m))        logger.debug('\t%-30s \t %11.2f' % ('Total credit utilization', cs['total_credit_utilization']))        logger.debug('\t%-30s \t $%10.2f' % ('Total debt remaining', cs['total_debt']))        logger.debug('\t%-30s \t $%10.2f' % ('Total available credit', cs['total_available_credit']))        logger.debug('\t%-30s \t $%10.2f' % ('Total revolving limit', cs['total_revolving_limit']))        logger.debug('\t%-30s \t $%10.2f' % ('Total annual interest', cs['total_annual_interest_due']))        describe_debts(debts) # Summarizes current active debts             results.append(ms)                if total_cash_available > 0:             logger.debug('\n\nCONGRATULATIONS - YOU WILL ACHIEVE FINANCIAL FREEDOM IN %d MONTH(S)!' % (m))            break         df_results = pd.DataFrame.from_records(results)    # plot_results(df_results)    